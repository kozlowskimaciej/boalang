<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>boalang: boalang</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">boalang
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">boalang </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>silne, stałe, wartość</code></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Przygotowanie środowiska</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Windows + WSL / Linux (Ubuntu 22.04)</h2>
<p>Wymagania: <code>CMake &gt;= 3.22</code>, <code>kompilator zgodny ze standardem C++20 (rekomendowany Clang-14)</code>, <code>Python &gt;= 3.6</code>, <code>Clang-Tidy</code></p>
<p>Opcjonalnie: <code>Clang-Format</code>, <code>Doxygen Graphviz</code></p>
<ol type="1">
<li>Pobieranie zależności potrzebnych do kompliacji <code>CMake</code>, <code>Python</code>, <code>Clang</code>: <code>sudo apt install cmake python3 python3.10-venv clang-14 clang-tidy</code></li>
<li>Klonowanie repozytorium: <code>git clone <a href="https://gitlab-stud.elka.pw.edu.pl/TKOM_24L_WW/Maciej_Kozlowski/tkom-boalang.git">https://gitlab-stud.elka.pw.edu.pl/TKOM_24L_WW/Maciej_Kozlowski/tkom-boalang.git</a></code></li>
<li>Instalacja i konfiguracja <code>Conan 2</code>, pierwszy build: <code>chmod +x configure.sh build.sh &amp;&amp; ./configure.sh</code> (skrypty jako argument pozycyjny mogą przyjąć Debug (domyślnie) lub Release)</li>
<li>Opcjonalnie:<ul>
<li>formatowanie kodu <code>sudo apt install clang-format &amp;&amp; cd build &amp;&amp; make format</code> (w projekcie użyty jest styl Google)</li>
<li>generowanie dokumentacji <code>sudo apt install doxygen graphviz &amp;&amp; cd build &amp;&amp; make docs</code></li>
<li>uruchamianie testów <code>cd build &amp;&amp; make test</code></li>
</ul>
</li>
</ol>
<p><code>Clang-Tidy</code> uruchamiane jest automatycznie na plikach źródłowych w trakcie kompilacji.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Sposób uruchamiania</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Windows + WSL / Linux (Ubuntu 22.04)</h2>
<ol type="1">
<li>Kompilacja: <code>./build.sh</code></li>
<li>Uruchamianie: <code>./build/src/boalang &lt;ścieżka_do_pliku&gt;</code> lub <code>./build/src/boalang --cmd "&lt;kod&gt;"</code></li>
</ol>
<h1><a class="anchor" id="autotoc_md5"></a>
Statystyki</h1>
<ul>
<li>liczba linii kodu: <b>6864</b> (<code>find . -type f \( -name "*.cpp" -o -name "*.hpp" -o -name "*.tpp" \) -print0 | xargs -0 wc -l</code>)</li>
<li>procentowe pokrycie kodu testami: <b>91%</b> (mierzone przy użyciu <code>llvm-cov</code>)</li>
<li>liczba testów: <b>243</b></li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Zasady działania języka</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Konwersja typów</h2>
<p>Język jest silnie typowany. Każda konwersja typu musi odbyć się jawnie przy użyciu operatora rzutowania <code>as</code>. W przypadku niepoprawnej konwersji rzucany jest wyjątek. Wyjątkiem są operacje logiczne, gdzie wartości domyślnie konwertowane są na <code>bool</code>.</p>
<div class="fragment"><div class="line">Przy pomoca operatora `is` mamy możliwość badania typu.</div>
</div><!-- fragment --><p> variant V { int, str };</p>
<p>mut V vrnt = "10"; str text = "";</p>
<p>if ( vrnt is int ) { text = (vrnt as int) as str; }</p>
<p>print text; </p><div class="fragment"><div class="line">Konwertowanie typów bazowych przy pomocy operatora `as`:</div>
<div class="line"> </div>
<div class="line">| Z \ Na | int | float | str | bool |  </div>
<div class="line">|--------|----|-------|--|--|</div>
<div class="line">| int    | 〰️️  | ✔️    | ✔️ | ✔️ |</div>
<div class="line">| float  | ✔️   | 〰️️    | ✔️ | ✔️ |</div>
<div class="line">| str    |  ❌  | ❌     | 〰️️ | ✔️ |</div>
<div class="line">| bool   |  ❌  | ❌     | ✔️ | 〰️️ |</div>
<div class="line"> </div>
<div class="line">W przypadku `variant`ów możemy dokonać konwersji na typ znajdujący się wewnątrz `variant`a. Ewentualnie możemy skorzystać z mechanizmu `inspect` do wykonywania różnych operacji dla różnych typów.</div>
<div class="line"> </div>
<div class="line">W przypadku `struct`ów nie ma możliwości castowania na inny typ niż ten sam.</div>
<div class="line"> </div>
<div class="line">Wypisywanie danych na standardowe wyjście odbywa się poprzez użycie słowa kluczowego `print`. Printować można jedynie wartości typów `str`, `int`, `bool` i `float`.</div>
<div class="line"> </div>
<div class="line">### Mutowanie zmiennych</div>
<div class="line"> </div>
<div class="line">Wszystkie zmienne są domyślnie stałe w momencie ich tworzenia. Tzn. po inicjalizacji zmiennej, jej wartość nie zmieni się do końca jej istnienia. Użycie słowa kluczowego `mut` przed nazwą typu umożliwia nadpisywanie wartości zmiennych po inicjalizacji.</div>
</div><!-- fragment --><p> mut int a = 5; a = 10; // OK int b = 5; b = 10; // BŁĄD, PRÓBA PRZYPISANIA NOWEJ WARTOŚCI DO STAŁEJ </p><div class="fragment"><div class="line">W przypadku struktur (`struct`), `mut` lub jego brak nie wpływa na pola struktury.</div>
</div><!-- fragment --><p> struct S { mut int a; int b; }</p>
<p>S obj = {1, 2}; obj.a = 3; // OK obj.b = 3; // BŁĄD, PRÓBA PRZYPISANIA NOWEJ WARTOŚCI DO STAŁEJ </p><div class="fragment"><div class="line">### Zasady przykrywania zmiennych</div>
<div class="line"> </div>
<div class="line">Zmienne, funkcje oraz typy nie mogą być przykrywane w podrzędnych scope&#39;ach, jedynie w oddzielnych kontekstach zawołań.</div>
</div><!-- fragment --><p> int a = 5; { int a = 10; // BŁĄD, ZMIENNA 'a' JUŻ ISTNIEJE }</p>
<p>void func(int n) { variant V{int, float}; // rekursywne tworzenie typu w funkcji void nested_func(){} // rekursywne tworzenie funkcji w funkcji int var = 1; // rekursywne tworzenie zmiennej w funkcji if (n &lt; 5) { n = n + 1; func(n); } return; } func(1); </p><div class="fragment"><div class="line">### Funkcje</div>
<div class="line"> </div>
<div class="line">Przeciążanie funkcji jest niedozwolone.</div>
<div class="line"> </div>
<div class="line">Przekazywanie zmiennych do funkcji przez wartość.</div>
<div class="line"> </div>
<div class="line">Parametry funkcji zawsze mutowalne.</div>
<div class="line"> </div>
<div class="line">Funkcje mogą wywoływać same siebie (rekursja).</div>
<div class="line"> </div>
<div class="line">Użycie `return` w funkcji powoduje, że reszta kodu w ciele funkcji nie jest wykonywana. Jest natychmiastowo zwracana podana wartość. W przypadku funkcji typu `void` nic nie jest zwracane.</div>
<div class="line"> </div>
<div class="line">### Komunikaty o błędach</div>
<div class="line"> </div>
<div class="line">**Błędy analizatora semantycznego**</div>
<div class="line"> </div>
<div class="line">`LexerError: Line {number} column {number} at &#39;{lexeme}&#39;: {message}`</div>
<div class="line"> </div>
<div class="line">Przykład:</div>
<div class="line"> </div>
<div class="line">`LexerError: Line 6 column 8 at &#39;999999999999999999&#39;: Type int limit exceeded`</div>
<div class="line">`LexerError: Line 6 column 8 at &#39;12..&#39;: Unknown token type`</div>
<div class="line"> </div>
<div class="line">**Błędy analizatora składniowego**</div>
<div class="line"> </div>
<div class="line">`SyntaxError: Line {number} column {number} at &#39;{lexeme}&#39;: {message}`</div>
<div class="line"> </div>
<div class="line">Przykład:</div>
<div class="line"> </div>
<div class="line">`SyntaxError: Line 12 column 5 at &#39;int&#39;: Expected &#39;)&#39; after expression.`</div>
<div class="line"> </div>
<div class="line">`SyntaxError: Line 12 column 5 at &#39;&quot;tekst&quot;&#39;: Expected &#39;;&#39; after expression.`</div>
<div class="line"> </div>
<div class="line">**Błędy interpretera**</div>
<div class="line"> </div>
<div class="line">`RuntimeError: Line {number} column {number}: {message}`</div>
<div class="line"> </div>
<div class="line">Przykład:</div>
<div class="line"> </div>
<div class="line">`RuntimeError: Line 4 column 8: Non-void function did not return a value`</div>
<div class="line"> </div>
<div class="line">`RuntimeError: Line 4 column 7: Type mismatch in initalizer list for &#39;a.number&#39;`</div>
<div class="line"> </div>
<div class="line">### Inne założenia</div>
<div class="line"> </div>
<div class="line">Wszystkie zmienne są `truthy` (w wyrażeniach logicznych występują jako `true`), poza `false`, `&quot;&quot;` (pusty string), `0`, `0.0`, które są `falsy`.</div>
<div class="line"> </div>
<div class="line">Język pozwala na umieszczenie w kodzie dwóch rodzajów komentarzy:</div>
<div class="line"> </div>
<div class="line">- `//` zakończone znakiem nowej linii `\n`</div>
<div class="line">- `/*` zakończone `*/`</div>
</div><!-- fragment --><p> print "Hello World!"; print 123; </p><div class="fragment"><div class="line">Zmienne zawsze muszą być zainicjalizowane.</div>
<div class="line"> </div>
<div class="line">Przypisanie zmiennej do innej zmiennej powoduje skopiowanie jej wartości.</div>
<div class="line"> </div>
<div class="line">Długość identyfikatorów i zakres wartości zmiennych `int` i `float` ograniczone.</div>
<div class="line"> </div>
<div class="line">## Struktura projektu</div>
<div class="line"> </div>
<div class="line">`Source` - abstrakcja dostępu do kodu źródłowego (ciąg znaków/plik)</div>
<div class="line"> </div>
<div class="line">`Lexer` - leniwe generowanie `Token`ów z `Source`</div>
<div class="line"> </div>
<div class="line">`Parser` - konsumuje tokeny wygenerowane przez `Lexer`, tworzy `drzewo AST`</div>
<div class="line"> </div>
<div class="line">`Interpreter` - wykonuje instrukcje z `drzewa AST`</div>
<div class="line"> </div>
<div class="line">![Architecture](docs/img/architecture.jpg)</div>
<div class="line"> </div>
<div class="line">## Testownie</div>
<div class="line"> </div>
<div class="line">- testy jednostkowe analizatora leksykalnego</div>
<div class="line"> </div>
<div class="line">- testy integracyjne analizatora leksykalnego i składniowego</div>
<div class="line"> </div>
<div class="line">- testy E2E - testowanie interpretera z wykorzystaniem przykładowych programów</div>
<div class="line"> </div>
<div class="line">## Gramatyka EBNF</div>
</div><!-- fragment --><p> program = { statement } ;</p>
<p>statement = if_stmt | while_stmt | return_stmt | print_stmt | inspect_stmt | block_stmt | struct_decl | variant_decl | var_or_func ; if_stmt = "if" "(" expression ")" statement [ "else" statement ] ; while_stmt = "while" "(" expression ")" statement ; return_stmt = "return" [ expression ] ";" ; print_stmt = "print" expression ";" ;</p>
<p>inspect_stmt = "inspect" expression "{" { lambda_func } [ "default" "=&gt;" block_stmt ] "}" ; lambda_func = type identifier "=&gt;" block_stmt ;</p>
<p>block_stmt = "{" { statement } "}" ;</p>
<p>struct_decl = "struct" identifier "{" { struct_field } "}" ; struct_field = [ "mut" ] type identifier ";" ;</p>
<p>variant_decl = "variant" identifier "{" variant_params "}" ";" ; variant_params = type { "," type } ;</p>
<p>var_or_func = mut_var_decl | void_func_decl | identifier assign_or_call | type var_or_func_decl ;</p>
<p>assign_or_call = ( assign_stmt | call_stmt ) ; assign_stmt = [ "." field_access ] "=" expression ";" ; call_stmt = "(" [ arguments ] ");" ;</p>
<p>var_or_func_decl= identifier ( var_decl | func_decl ) ; mut_var_decl = "mut" type identifier var_decl ; void_func_decl = "void" identifier func_decl ;</p>
<p>var_decl = "=" expression ";" ; func_decl = "(" [ func_params ] ")" block_stmt ; func_params = type identifier { "," type identifier } ;</p>
<p>expression = logic_or ; logic_or = logic_and { "or" logic_and } ; logic_and = equality { "and" equality } ; equality = comparison { ( "!=" | "==" ) comparison } ; comparison = term { ( "&gt;" | "&gt;=" | "&lt;" | "&lt;=" ) term } ; term = factor { ( "-" | "+" ) factor } ; factor = unary { ( "/" | "*" ) unary } ; unary = [ "!" | "-" ] type_cast ; type_cast = call { ("as" | "is") type } ; call = primary [ "(" [ arguments ] ")" | field_access ] ; primary = string | int_val | float_val | bool_values | identifier | "(" expression ")" | "{" arguments "}" ;</p>
<p>arguments = expression { "," expression } ; field_access = { "." identifier } ;</p>
<p>bool_value = "true" | "false" ; type = "bool" | "str" | "int" | "float" | identifier ;</p>
<p>string = '"' { ANY } '"' ; float_val = int_val "." DIGIT { DIGIT } ; int_val = "0" | ( DIGIT_POSITIVE { DIGIT } ) ; identifier = ( LETTER | "_" ) { LETTER | DIGIT | "_" } ;</p>
<p>ANY = [^"\r<br  />
]; LETTER = [a-zA-Z] ; DIGIT = [1-9] ; DIGIT_POSITIVE = [0-9] ; </p><div class="fragment"><div class="line">## Przykłady</div>
</div><!-- fragment --><p> /* STRUCT */ struct S { mut int a; float b; }</p>
<p>mut S st_obj = {6, 1.0}; st_obj.a = st_obj.b as int;</p>
<p>S another_st_obj = {1, 6.0}; st_obj = another_st_obj; // another_st_obj = st_obj; // BŁĄD, próba przypisania wartości do stałej</p>
<p>/* VARIANT */ variant V { int, float, S };</p>
<p>mut V varnt_obj = st_obj;</p>
<p>if ( varnt_obj is S ) { print (varnt_obj as S).a; }</p>
<p>inspect varnt_obj { int val =&gt; {print val;} float val =&gt; {print val;} S val =&gt; {print val.a;} default =&gt; {print "default";} }</p>
<p>/* PRINT &amp; WHILE */ mut int a = 1; while (a &lt;= 5) { print a; // 1 2 3 4 5 a = a + 1; <br  />
 }</p>
<p>/* LOGICAL OPERATORS */ a = 1; mut bool b = false; b = a as bool; // true b = !a; // false b = a or false; // true b = a and false; // false</p>
<p>int c = 2; b = a &gt;= c; // true <br  />
 b = a &lt; c; // false b = a &lt;= c; // false</p>
<p>/* FUNCTIONS */ variant Numeric { int, float };</p>
<p>Numeric fib(Numeric n) { inspect n { int val =&gt; { if (val == 1 or val == 2) { return 1; } Numeric n1 = val - 1; Numeric n2 = val - 2; Numeric result = fib(n1) as int + fib(n2) as int; return result; } float val =&gt; { if (val == 1.0 or val == 2.0) { return 1.0; } Numeric n1 = val - 1.0; Numeric n2 = val - 2.0; Numeric result = fib(n1) as float + fib(n2) as float; return result; } } }</p>
<p>Numeric val = 3; int fibval = fib(val) as int; print fibval; ```</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Podsumowanie</h1>
<p>Udało się zaimplementować wszystkie planowane funkcjonalności języka. W stosunku do planowanego rozwiązania zmienił się sposób zapisu kilku reguł z gramatyki. Produkt końcowy umożliwia uruchomienie kodu napisanego w języku <code>boalang</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 14 2024 19:57:33 for boalang by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
